var documenterSearchIndex = {"docs":
[{"location":"look_at_general/#A-look-at-the-General-registry","page":"A look at the General registry","title":"A look at the General registry","text":"","category":"section"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"First, let's load in the data.","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"using Arrow, AnalyzeRegistry, DataFrames\nArrow.ArrowTypes.registertype!(AnalyzeRegistry.Package, AnalyzeRegistry.Package)\n\n# https://github.com/JuliaData/Arrow.jl/issues/132\nArrow.ArrowTypes.JULIA_TO_ARROW_TYPE_MAPPING[Nothing] = (\"JuliaLang.Nothing\", Nothing)\nArrow.ArrowTypes.ARROW_TO_JULIA_TYPE_MAPPING[\"JuliaLang.Nothing\"] = (Nothing, Nothing)\n\nload(path) = copy(Arrow.Table(path).packages)\n\nresults = load(\"assets/all_pkgs_results.arrow\")\n\n# https://discourse.julialang.org/t/slowness-of-fieldnames-and-properynames/55364/2\n@generated function named_tuple(obj::T) where {T}\n    NT = NamedTuple{fieldnames(obj), Tuple{fieldtypes(obj)...}}\n    return :($NT(tuple($((:(getfield(obj, $i)) for i in 1:fieldcount(obj))...))))\nend\n\ndf = DataFrame(named_tuple.(results))\nsort!(df, :name)\ndf[1:5, Not([:uuid, :lines_of_code, :license_files])]","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"Here, we see some information about presence of docs, tests, and CI, for the first five packages (alphabetically). We omit the lines_of_code and license_files fields, since these are tables of their own that we'll look at next.","category":"page"},{"location":"look_at_general/#Lines-of-code","page":"A look at the General registry","title":"Lines of code","text":"","category":"section"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"Let us assemble all of the lines_of_code tables into their own DataFrame.","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"loc_df = DataFrame()\nfor pkg in results\n    pkg_df = DataFrame(pkg.lines_of_code)\n    insertcols!(pkg_df, 1, :name => fill(pkg.name, nrow(pkg_df)))\n    append!(loc_df, pkg_df)\nend\nsort!(loc_df, :code; rev=true)\nloc_df[1:10, :]","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"We can see the largest entries by lines of code seem to be mostly generated code, like plots or HTML. Let's look at just at Julia language code in the src directory (with no sublanguage, i.e. it's not another language embedded inside Julia):","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"grps = groupby(loc_df, [:directory, :language, :sublanguage])\nsrc_code = DataFrame(grps[(; directory=\"src\", language=:Julia, sublanguage=nothing)])\nsort!(src_code, :code; rev=true)\nsrc_code[1:20, Not([:sublanguage])]","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"sum(src_code.code)","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"We see there are almost 7 million lines of Julia source code in General!","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"using GRUtils\nFigure(); # hide\nhistogram(src_code.code, xlog=true, xlabel=\"Lines of Julia source code\",\n          ylabel=\"Number of packages\")","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"With a logarithmic x-axis, we see a nice unimodal distribution, centered around ~500 lines of code:","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"using StatsBase\nsummarystats(src_code.code)","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"We can also generate a wordcloud with the names of the 500 largest packages:","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"using WordCloud\nsrc_wc = generate!(wordcloud(src_code.name[1:500], src_code.code[1:500]))\npaint(src_wc, \"assets/src_wc.svg\")","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"(Image: Word cloud)","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"In the package folder, where does Julia code live?","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"dir_grps = groupby(filter(:language => isequal(:Julia), loc_df), :directory)\ndir_df = sort!(combine(dir_grps, :code => sum => :loc), :loc; rev=true)\nn_bars=6\nheights = [dir_df.loc[1:(n_bars-1)]; sum(dir_df.loc[n_bars+1:end])]\nlabels = [dir_df.directory[1:(n_bars-1)]; \"other\"]\nFigure(); # hide\nbarplot(labels, heights; ylabel=\"Total lines of Julia code\", xlabel=\"Top-level directory\")\nannotations(1:length(heights), heights .+ 0.03 * maximum(heights) , string.(heights), halign=\"center\")\nxticks(1)","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"Mostly in src, as expected! What's the most common non-Julia code in src?","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"grps = groupby(filter([:directory, :language] => ((d, l) -> d == \"src\" && l !== :Julia), loc_df), :language)\n\nsort!(combine(grps, :code => sum, [:name, :code] => ((n, c) -> n[argmax(c)]) => :biggest_contributer, :code => maximum => :biggest_contribution), :code_sum; rev=true)[1:10, :]","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"We see code from a variety of different languages can live in src, but often most of the lines come from a single package. Note the \"Invalid Project.toml\"; this likely means the package in question does not have a Project.toml at all (and instead still has the old Requires file).","category":"page"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"We could continue exploring this all day, but instead we suggest you download the data and do some digging yourself!","category":"page"},{"location":"look_at_general/#Licenses","page":"A look at the General registry","title":"Licenses","text":"","category":"section"},{"location":"look_at_general/","page":"A look at the General registry","title":"A look at the General registry","text":"license_df = DataFrame()\nfor pkg in results\n    pkg_df = DataFrame(pkg.license_files)\n    insertcols!(pkg_df, 1, :name => fill(pkg.name, nrow(pkg_df)))\n    append!(license_df, pkg_df)\nend\nsort!(license_df, :licenses_found; by=length, rev=true)\nlicense_df[1:10, :]","category":"page"},{"location":"api/#API-reference","page":"API Reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [AnalyzeRegistry]","category":"page"},{"location":"api/#AnalyzeRegistry.analyze-Tuple{AbstractString}","page":"API Reference","title":"AnalyzeRegistry.analyze","text":"analyze(dir::AbstractString; repo = \"\", reachable=true, name=nothing, uuid=nothing)\n\nAnalyze the package whose source code is located at dir. Optionally repo and reachable a boolean indicating whether or not the package is reachable online, since these can't be inferred from the source code. If name or uuid are nothing, the directories Project.toml is parsed to infer the package's name and UUID.\n\nExample\n\njulia> using DataFrames\n\njulia> analyze(pkgdir(DataFrames))\nPackage DataFrames:\n  * repo:\n  * uuid: a93c6f00-e57d-5684-b7b6-d8193f3e46c0\n  * is reachable: true\n  * lines of Julia code in `src`: 15347\n  * lines of Julia code in `test`: 15654\n  * has license(s) in file: MIT\n    * filename: LICENSE.md\n    * OSI approved: true\n  * has documentation: true\n  * has tests: true\n  * has continuous integration: true\n    * GitHub Actions\n\n\n\n\n\n\n","category":"method"},{"location":"api/#AnalyzeRegistry.analyze_from_registry!-Tuple{Any, AbstractString}","page":"API Reference","title":"AnalyzeRegistry.analyze_from_registry!","text":"analyze_from_registry!(root, dir::AbstractString) -> Package\n\nAnalyze the package whose entry in the registry is in the dir directory, cloning the package code to joinpath(root, uuid) where uuid is the UUID of the package, if such a directory does not already exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#AnalyzeRegistry.analyze_from_registry!-Tuple{Any, AbstractVector{var\"#s31\"} where var\"#s31\"<:AbstractString}","page":"API Reference","title":"AnalyzeRegistry.analyze_from_registry!","text":"analyze_from_registry!(root, packages::AbstractVector{<:AbstractString}) -> Vector{Package}\n\nAnalyze all packages in the iterable packages, using threads, cloning them to root if a directory with their uuid does not already exist.  Returns a Vector{Package}.\n\n\n\n\n\n","category":"method"},{"location":"api/#AnalyzeRegistry.analyze_from_registry-Tuple{Any}","page":"API Reference","title":"AnalyzeRegistry.analyze_from_registry","text":"analyze_from_registry(dir::AbstractString) -> Package\nanalyze_from_registry(packages::AbstractVector{<:AbstractString}) -> Vector{Package}\n\nAnalyzes a package or list of packages using the information in their directory in a registry by creating a temporary directory and calling analyze_from_registry!, cleaning up the temporary directory afterwards.\n\nExample\n\njulia> analyze_from_registry(joinpath(general_registry(), \"B\", \"BinaryBuilder\"))\nPackage BinaryBuilder:\n  * repo: https://github.com/JuliaPackaging/BinaryBuilder.jl.git\n  * uuid: 12aac903-9f7c-5d81-afc2-d9565ea332ae\n  * is reachable: true\n  * lines of Julia code in `src`: 4733\n  * lines of Julia code in `test`: 1520\n  * has license(s) in file: MIT\n    * filename: LICENSE.md\n    * OSI approved: true\n  * has documentation: true\n  * has tests: true\n  * has continuous integration: true\n    * GitHub Actions\n    * Azure Pipelines\n\n\n\n\n\n\n","category":"method"},{"location":"api/#AnalyzeRegistry.find_package-Tuple{AbstractString}","page":"API Reference","title":"AnalyzeRegistry.find_package","text":"find_package(pkg; registry = general_registry()) -> String\n\nReturns the path to the entry in registry for the package pkg. The singular version of find_packages.\n\n\n\n\n\n","category":"method"},{"location":"api/#AnalyzeRegistry.find_packages","page":"API Reference","title":"AnalyzeRegistry.find_packages","text":"find_packages(; registry = general_registry()) -> Vector{String}\nfind_packages(names::AbstractString...; registry = general_registry()) -> Vector{String}\nfind_packages(names; registry = general_registry()) -> Vector{String}\n\nFind all packages in the given registry (specified by the registry keyword argument), the General registry by default. Return a vector with the paths to the directories of each package in the registry.\n\nPass a list of package names as the first argument to return the paths corresponding to those packages, or individual package names as separate arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#AnalyzeRegistry.general_registry-Tuple{}","page":"API Reference","title":"AnalyzeRegistry.general_registry","text":"general_registry() -> String\n\nGuess the path of the General registry.\n\n\n\n\n\n","category":"method"},{"location":"serialization/#Saving-results","page":"Saving results","title":"Saving results","text":"","category":"section"},{"location":"serialization/","page":"Saving results","title":"Saving results","text":"In just four lines of code, we can setup serialization of collections of AnalyzeRegistry's Package object to Apache arrow tables:","category":"page"},{"location":"serialization/","page":"Saving results","title":"Saving results","text":"using Arrow, AnalyzeRegistry\nArrow.ArrowTypes.registertype!(AnalyzeRegistry.Package, AnalyzeRegistry.Package)\nsave(path, packages) = Arrow.write(path, (; packages))\nload(path) = copy(Arrow.Table(path).packages)","category":"page"},{"location":"serialization/","page":"Saving results","title":"Saving results","text":"Then we can do e.g.","category":"page"},{"location":"serialization/","page":"Saving results","title":"Saving results","text":"results = analyze_from_registry(find_packages(\"DataFrames\", \"Flux\"));\nsave(\"packages.arrow\", results)\nroundtripped_results = load(\"packages.arrow\")\nrm(\"packages.arrow\") # hide","category":"page"},{"location":"serialization/","page":"Saving results","title":"Saving results","text":"Note that even if future versions of AnalyzeRegistry change the layout of Package's and you forget the version used to serialize the results, you can use the same load function without calling registertype! in the Julia session in order to deserialize the results back as NamedTuple's (instead of as Packages), providing some amount of robustness.","category":"page"},{"location":"#AnalyzeRegistry.jl","page":"Home","title":"AnalyzeRegistry.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main functionality of the package are the analyze and analyze_from_registry functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using AnalyzeRegistry\n\njulia> analyze_from_registry(find_package(\"Flux\"))\nPackage Flux:\n  * repo: https://github.com/FluxML/Flux.jl.git\n  * uuid: 587475ba-b771-5e3f-ad9e-33799f191a9c\n  * is reachable: true\n  * lines of Julia code in `src`: 4863\n  * lines of Julia code in `test`: 2034\n  * has license(s) in file: MIT\n    * filename: LICENSE.md\n    * OSI approved: true\n  * has documentation: true\n  * has tests: true\n  * has continuous integration: true\n    * GitHub Actions\n    * Buildkite\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"The argument is the path to the directory of the package in the registry, where the file Package.toml is stored.  The function find_package gives you the path to the package in your local copy of the General registry.","category":"page"},{"location":"","page":"Home","title":"Home","text":"NOTE: the Git repository of the package will be cloned, in order to inspect its content.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You use the inplace version analyze_from_registry!, e.g. as analyze_from_registry!(root, find_package(\"Flux\")) to clone the package to a particular directory root which is not cleaned up afterwards, and likewise can pass a vector of paths instead of a single path employ use a threaded loop to analyze each package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also directly analyze the source code of a package via analyze, for example","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using AnalyzeRegistry, DataFrames\n\njulia> analyze(pkgdir(DataFrames))\nPackage DataFrames:\n  * repo:\n  * uuid: a93c6f00-e57d-5684-b7b6-d8193f3e46c0\n  * is reachable: true\n  * lines of Julia code in `src`: 15347\n  * lines of Julia code in `test`: 15654\n  * has license(s) in file: MIT\n    * filename: LICENSE.md\n    * OSI approved: true\n  * has documentation: true\n  * has tests: true\n  * has continuous integration: true\n    * GitHub Actions","category":"page"},{"location":"#The-Package-struct","page":"Home","title":"The Package struct","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The returned values from analyze, analyze_from_registry and analyze_from_registry! are objects of the type Package, which has the following fields:","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct Package\n    name::String # name of the package\n    uuid::UUID # uuid of the package\n    repo::String # URL of the repository\n    subdir::String # subdirectory of the package in the repo\n    reachable::Bool # can the repository be cloned?\n    docs::Bool # does it have documentation?\n    runtests::Bool # does it have the test/runtests.jl file?\n    github_actions::Bool # does it use GitHub Actions?\n    travis::Bool # does it use Travis CI?\n    appveyor::Bool # does it use AppVeyor?\n    cirrus::Bool # does it use Cirrus CI?\n    circle::Bool # does it use Circle CI?\n    drone::Bool # does it use Drone CI?\n    buildkite::Bool # does it use Buildkite?\n    azure_pipelines::Bool # does it use Azure Pipelines?\n    gitlab_pipeline::Bool # does it use Gitlab Pipeline?\n    license_filename::Union{Missing, String} # e.g. `LICENSE` or `COPYING`\n    licenses_found::Vector{String} # all the licenses found in `license_filename`\n    license_file_percent_covered::Union{Missing, Float64} # how much of the license file is covered by the licenses found\n    licenses_in_project::Union{Missing,Vector{String}} # any licenses in the `license` key of the Project.toml\n    lines_of_code::Vector{@NamedTuple{directory::String, language::Symbol, sublanguage::Union{Nothing, Symbol}, files::Int, code::Int, comments::Int, blanks::Int}} # table of lines of code\nend","category":"page"},{"location":"#Analyzing-multiple-packages","page":"Home","title":"Analyzing multiple packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To run the analysis for multiple packages you can either use broadcasting","category":"page"},{"location":"","page":"Home","title":"Home","text":"analyze_from_registry.(package_paths_in_registry)","category":"page"},{"location":"","page":"Home","title":"Home","text":"or use the method analyze_from_registry(package_paths_in_registry::AbstractVector{<:AbstractString}) which leaverages FLoops.jl to run the analysis with multiple threads.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can use the function find_packages to find all packages in a given registry:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> find_packages(; registry=general_registry())\n4312-element Vector{String}:\n \"/home/user/.julia/registries/General/C/CitableImage\"\n \"/home/user/.julia/registries/General/T/Trixi2Img\"\n \"/home/user/.julia/registries/General/I/ImPlot\"\n \"/home/user/.julia/registries/General/S/StableDQMC\"\n \"/home/user/.julia/registries/General/S/Strapping\"\n [...]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Do not abuse this function! Consider using the in-place function analyze_from_registry!(root, package_paths_in_registry) to avoid re-cloning packages if you might run the analysis more than once.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nCloning all the repos in General will take about 24 GB of disk space and likely take several hours to complete.","category":"page"},{"location":"#License-information","page":"Home","title":"License information","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The license_files field of the Package object is a Tables.jl row table containing much more detailed information about any or all files containing licenses, identified by licensecheck via LicenseCheck.jl. For example, RandomProjectionTree.jl is dual licensed under both Apache-2.0 and the MIT license, and provides two separate license files. Interestingly, the README is also identified as containing an Apache-2.0 license; I've filed an issue to see if this is intentional.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using AnalyzeRegistry, DataFrames\n\njulia> result = analyze_from_registry(find_packages(\"RandomProjectionTree\")[1]);\n\njulia> DataFrame(result.license_files)\n3×3 DataFrame\n Row │ license_filename  licenses_found  license_file_percent_covered\n     │ String            Vector{String}  Float64\n─────┼────────────────────────────────────────────────────────────────\n   1 │ LICENSE-APACHE    [\"Apache-2.0\"]                     100.0\n   2 │ LICENSE-MIT       [\"MIT\"]                            100.0\n   3 │ README.md         [\"Apache-2.0\"]                       6.34921","category":"page"},{"location":"","page":"Home","title":"Home","text":"Most packages contain a single file containing a license, and so have a single entry in the table.","category":"page"},{"location":"#Lines-of-code","page":"Home","title":"Lines of code","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The lines_of_code field of the Package object is a Tables.jl row table containing much more detailed information about the lines of code count (thanks to tokei) and can e.g. be passed to a DataFrame for further analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using AnalyzeRegistry, DataFrames\n\njulia> result = analyze(pkgdir(DataFrames));\n\njulia> DataFrame(result.lines_of_code)\n13×7 DataFrame\n Row │ directory        language  sublanguage  files  code   comments  blanks\n     │ String           Symbol    Union…       Int64  Int64  Int64     Int64\n─────┼────────────────────────────────────────────────────────────────────────\n   1 │ test             Julia                     27  15654       320    2109\n   2 │ src              Julia                     28  15347       794    1009\n   3 │ docs             Julia                      1     41         7       5\n   4 │ docs             TOML                       1      4         0       2\n   5 │ docs             Markdown                  14      0      3292     620\n   6 │ docs             Markdown  Julia            3     29         3       4\n   7 │ docs             Markdown  Python           1     13         0       1\n   8 │ docs             Markdown  R                1      2         0       0\n   9 │ Project.toml     TOML                       1     48         0       4\n  10 │ CONTRIBUTING.md  Markdown                   1      0        56       8\n  11 │ NEWS.md          Markdown                   1      0       112      10\n  12 │ LICENSE.md       Markdown                   1      0        22       1\n  13 │ README.md        Markdown                   1      0        21      10","category":"page"}]
}
